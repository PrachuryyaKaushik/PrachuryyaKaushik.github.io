<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Visualizer</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; }
        .container { display: flex; justify-content: center; align-items: center; margin-top: 20px; }
        .column { margin: 20px; position: relative; }
        .node { width: 50px; height: 50px; line-height: 50px; text-align: center; border-radius: 50%; display: block; margin: 15px auto; }
        .red { background-color: red; color: white; }
        .green { background-color: green; color: white; }
        .input, .output { width: 60px; margin: 5px; }
        .canvas-container { position: absolute; top: 0; left: 0; z-index: -1; }
    </style>
</head>
<body>
    <h1>Neural Network Visualizer</h1>
    <label>Number of Inputs:</label>
    <input type="number" id="numInputs" min="5" max="10" value="5">
    <label>Number of Hidden Units:</label>
    <input type="number" id="numHidden" min="8" max="12" value="8">
    <label>Number of Outputs:</label>
    <input type="number" id="numOutputs" min="2" max="4" value="2">
    <button onclick="initializeNetwork()">Set Network</button>
    
    <div class="container">
        <canvas id="networkCanvas" class="canvas-container"></canvas>
        <div id="inputLayer" class="column"></div>
        <div id="hiddenLayer" class="column"></div>
        <div id="outputLayer" class="column"></div>
    </div>
    <button onclick="nextEpoch()">Next Epoch</button>
    <p>Epoch: <span id="epoch">0</span></p>
    
    <script>
        let weights = { inputToHidden: [], hiddenToOutput: [] };
        let epoch = 0;
        let canvas, ctx;

        function initializeNetwork() {
            let numInputs = parseInt(document.getElementById("numInputs").value);
            let numHidden = parseInt(document.getElementById("numHidden").value);
            let numOutputs = parseInt(document.getElementById("numOutputs").value);
            epoch = 0;
            document.getElementById("epoch").innerText = epoch;
            
            weights.inputToHidden = Array.from({ length: numInputs }, () => Array(numHidden).fill(0).map(() => Math.random() * 2 - 1));
            weights.hiddenToOutput = Array.from({ length: numHidden }, () => Array(numOutputs).fill(0).map(() => Math.random() * 2 - 1));
            
            renderNetwork(numInputs, numHidden, numOutputs);
        }

        function renderNetwork(numInputs, numHidden, numOutputs) {
            let inputLayer = document.getElementById("inputLayer");
            let hiddenLayer = document.getElementById("hiddenLayer");
            let outputLayer = document.getElementById("outputLayer");
            
            inputLayer.innerHTML = '<h3>Inputs</h3>' + generateNodes(numInputs, "input");
            hiddenLayer.innerHTML = '<h3>Hidden</h3>' + generateNodes(numHidden, "hidden");
            outputLayer.innerHTML = '<h3>Outputs</h3>' + generateNodes(numOutputs, "output");
            
            drawConnections(numInputs, numHidden, numOutputs);
        }

        function generateNodes(count, type) {
            let html = '';
            for (let i = 0; i < count; i++) {
                html += `<div class="node ${type}">${type === 'input' ? 'I' + (i + 1) : (type === 'hidden' ? 'H' + (i + 1) : 'O' + (i + 1))}</div>`;
            }
            return html;
        }

        function drawConnections(numInputs, numHidden, numOutputs) {
            canvas = document.getElementById("networkCanvas");
            ctx = canvas.getContext("2d");
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            let inputNodes = document.querySelectorAll(".input");
            let hiddenNodes = document.querySelectorAll(".hidden");
            let outputNodes = document.querySelectorAll(".output");
            
            connectLayers(inputNodes, hiddenNodes);
            connectLayers(hiddenNodes, outputNodes);
        }

        function connectLayers(fromNodes, toNodes) {
            fromNodes.forEach(from => {
                let fromRect = from.getBoundingClientRect();
                toNodes.forEach(to => {
                    let toRect = to.getBoundingClientRect();
                    ctx.beginPath();
                    ctx.moveTo(fromRect.left + fromRect.width / 2, fromRect.top + fromRect.height / 2);
                    ctx.lineTo(toRect.left + toRect.width / 2, toRect.top + toRect.height / 2);
                    ctx.strokeStyle = "black";
                    ctx.lineWidth = 1;
                    ctx.stroke();
                });
            });
        }

        function nextEpoch() {
            epoch++;
            document.getElementById("epoch").innerText = epoch;
            
            weights.inputToHidden = weights.inputToHidden.map(row => row.map(w => w + (Math.random() - 0.5) * 0.1));
            weights.hiddenToOutput = weights.hiddenToOutput.map(row => row.map(w => w + (Math.random() - 0.5) * 0.1));
            
            renderNetwork(weights.inputToHidden.length, weights.inputToHidden[0].length, weights.hiddenToOutput[0].length);
        }
    </script>
</body>
</html>
