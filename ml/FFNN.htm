<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Visualizer</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; }
        .container { display: flex; justify-content: center; margin-top: 20px; }
        .column { margin: 10px; }
        .node { width: 50px; height: 50px; line-height: 50px; text-align: center; border-radius: 50%; display: inline-block; margin: 5px; }
        .red { background-color: red; color: white; }
        .green { background-color: green; color: white; }
        .input, .output { width: 60px; margin: 5px; }
        .weights { margin: 10px 0; }
    </style>
</head>
<body>
    <h1>Neural Network Visualizer</h1>
    <label>Inputs:</label>
    <input type="number" id="numInputs" min="5" max="10" value="5">
    <label>Hidden Units:</label>
    <input type="number" id="numHidden" min="8" max="12" value="8">
    <label>Outputs:</label>
    <input type="number" id="numOutputs" min="2" max="4" value="2">
    <button onclick="initializeNetwork()">Set Network</button>
    
    <div class="container">
        <div id="inputLayer" class="column"></div>
        <div id="hiddenLayer" class="column"></div>
        <div id="outputLayer" class="column"></div>
    </div>
    <button onclick="nextEpoch()">Next Epoch</button>
    <p>Epoch: <span id="epoch">0</span></p>
    
    <script>
        let weights = { inputToHidden: [], hiddenToOutput: [] };
        let epoch = 0;

        function initializeNetwork() {
            let numInputs = parseInt(document.getElementById("numInputs").value);
            let numHidden = parseInt(document.getElementById("numHidden").value);
            let numOutputs = parseInt(document.getElementById("numOutputs").value);
            epoch = 0;
            document.getElementById("epoch").innerText = epoch;
            
            weights.inputToHidden = Array.from({ length: numInputs }, () => Array(numHidden).fill(0).map(() => Math.random() * 2 - 1));
            weights.hiddenToOutput = Array.from({ length: numHidden }, () => Array(numOutputs).fill(0).map(() => Math.random() * 2 - 1));
            renderNetwork(numInputs, numHidden, numOutputs);
        }

        function renderNetwork(numInputs, numHidden, numOutputs) {
            let inputLayer = document.getElementById("inputLayer");
            let hiddenLayer = document.getElementById("hiddenLayer");
            let outputLayer = document.getElementById("outputLayer");
            
            inputLayer.innerHTML = '<h3>Inputs</h3>' + generateNodes(numInputs, "input");
            hiddenLayer.innerHTML = '<h3>Hidden</h3>' + generateWeights(weights.inputToHidden, "hidden");
            outputLayer.innerHTML = '<h3>Outputs</h3>' + generateWeights(weights.hiddenToOutput, "output");
        }

        function generateNodes(count, type) {
            let html = '';
            for (let i = 0; i < count; i++) {
                html += `<input class="${type}" type="number" value="0.5">`;
            }
            return html;
        }

        function generateWeights(weightMatrix, type) {
            let html = '<div class="weights">';
            for (let i = 0; i < weightMatrix.length; i++) {
                for (let j = 0; j < weightMatrix[i].length; j++) {
                    let color = weightMatrix[i][j] > 0 ? 'green' : 'red';
                    html += `<div class="node ${color}">${weightMatrix[i][j].toFixed(2)}</div>`;
                }
                html += '<br>';
            }
            html += '</div>';
            return html;
        }

        function nextEpoch() {
            epoch++;
            document.getElementById("epoch").innerText = epoch;
            
            weights.inputToHidden = weights.inputToHidden.map(row => row.map(w => w + (Math.random() - 0.5) * 0.1));
            weights.hiddenToOutput = weights.hiddenToOutput.map(row => row.map(w => w + (Math.random() - 0.5) * 0.1));
            
            renderNetwork(weights.inputToHidden.length, weights.inputToHidden[0].length, weights.hiddenToOutput[0].length);
        }
    </script>
</body>
</html>
